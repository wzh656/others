<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>我的世界（电脑版）</title>
		<style>
			body{
				margin: 0;
				overflow: hidden;
				/* 隐藏body窗口区域滚动条 */
			}
			#loading{
				position: absolute;
				width: 100%;
				height: 100%;
				margin: 0;
				padding-top: 20%;
				text-align: center;
				color: #fff;
				background-color: #000;
			}
		</style>
		<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
		<script src="./node_modules/stats.js/build/stats.min.js"></script>
		<script src="./node_modules/dat.gui/build/dat.gui.min.js"></script>
		<script src="./node_modules/three/build/three.min.js"></script>
		<script src="./node_modules/three/examples/js/controls/OrbitControls.js"></script>
	</head>

	<body>
		<h1 id="loading">
			<span id="schedule_message">贴图加载中……</span><br/>
			主进度：<span id="schedule1">0</span>%<br/>
			次进度：<span id="schedule2">0</span>%
		</h1>
<script>
var scene, camera;
const blocks = [
	{
		name: "空气",
		texture: []
	},
	{
		name: "草方块",
		texture: []
	},
	{
		name: "木板",
		texture: []
	}
];
const every = [];
for (let x=-10; x<=10; x++){
	every[x] = [];
	for (let y=0; y<=20; y++){
		every[x][y] = [];
		for (let z=-10; z<=10; z++){
			if (y == 0){
				if (x < 0){
					every[x][y][z] = 1;
				}else{
					every[x][y][z] = 2;
				}
			}else{
				every[x][y][z] = 0;
			}
		}
	}
}

window.onload = function (){
	/**
	* dat.gui
	*/
	var gui = new dat.GUI({
		name: "信息",
		useLocalStorage: true, // 使用LocalStorage来存储
		closeOnTop: true // 关闭按钮是否在顶部
	});
	/**
	* 创建场景对象Scene
	*/
	scene = new THREE.Scene();
	
	/**
	* 创建网格模型
	*/
	/* var geometry = new THREE.BoxGeometry(100, 200, 300); //创建一个立方体几何对象Geometry
	var material = new THREE.MeshLambertMaterial({
	color: 0x66ff88
	}); //材质对象Material
	var mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh
	mesh.position.x = 1;
	scene.add(mesh); //网格模型添加到场景中 */
	
	let block_geometry = new THREE.BoxGeometry(100, 100, 100);
	// TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理
	let textureLoader = new THREE.TextureLoader();
	let num = 0;
	for (let i in blocks){
		for (let j=1; j<=6; j++){
			textureLoader.load(`./img/blocks/${blocks[i].name}/${j}.png`, function (texture){
				blocks[i].texture[j] = texture;
				document.getElementById("schedule2").innerHTML = Math.round((blocks[i].texture.length-1)/6*100)/100;
				//显示进度
				setTimeout(() => {
					if (blocks[i].texture.length < 7)
						return;
					
					//单个block加载完毕
					for (let k=1;k<blocks[i].texture.length;k++)
						if (blocks[i].texture[k] == undefined)
							return;
					blocks[i].material = [
						new THREE.MeshLambertMaterial({ map: blocks[i].texture[1] }),
						new THREE.MeshLambertMaterial({ map: blocks[i].texture[2] }),
						new THREE.MeshLambertMaterial({ map: blocks[i].texture[3] }),
						new THREE.MeshLambertMaterial({ map: blocks[i].texture[4] }),
						new THREE.MeshLambertMaterial({ map: blocks[i].texture[5] }),
						new THREE.MeshLambertMaterial({ map: blocks[i].texture[6] })
					]; //材质对象Material
					document.getElementById("schedule1").innerHTML = Math.round(i/6*100)/100;
					//显示进度
					setTimeout(() => {
						for (let k in blocks)
							if (blocks[k].material == undefined)
								return;
						//所有block加载完毕
						document.getElementById("schedule_message").innerHTML = "载入方块中……";
						setTimeout(() => {
							for (let x=-10;x<=10;x++){
								console.log("loading:", x);
								for (let y=0;y<=20;y++){
									for (let z=-10;z<=10;z++){
										document.getElementById("schedule1").innerHTML = Math.round(x/20*100)/100;
										document.getElementById("schedule2").innerHTML = Math.round(y/20*100)/100;
										if (every[x][y][z] == 0) //空气
											continue;
										let mesh = new THREE.Mesh(block_geometry, blocks[ every[x][y][z] ].material); //网格模型对象Mesh
										mesh.position.x = x*100;
										mesh.position.y = y*100;
										mesh.position.z = z*100;
										scene.add(mesh); //网格模型添加到场景中
									}
								}
							}
							//纹理贴图加载成功后，调用渲染函数执行渲染操作
							render();
							document.getElementById("loading").remove();
						},6);
					},6);
				},6);
			});
		}
	}
	
	/* var floor_geometry = new THREE.PlaneGeometry(1000, 1000, 6, 6);
	var floor_material = new THREE.MeshBasicMaterial({ color:"#fff"});
	//floor_material.wireframe = true; //仅框架
	floor_mesh = new THREE.Mesh(floor_geometry, floor_material);
	// 由于平地添加后默认是在正前方 所以需要旋转一下
	floor_mesh.rotation.x = -0.5 * Math.PI;
	floor_mesh.position.y = -10;
	scene.add(floor_mesh); */
	
	
	var line = [];
	var line_geometry = [];
	var line_material = [];
	
	line_geometry[0] = new THREE.Geometry();
	line_geometry[0].vertices.push(new THREE.Vector3( -1000, 0, 0) );
	line_geometry[0].vertices.push(new THREE.Vector3( 1000, 0, 0) );
	line_material[0] = new THREE.LineBasicMaterial({
		color: 0xffffff
	});
	line[0] = new THREE.Line(line_geometry[0], line_material[0]);
	scene.add(line[0]);
	
	line_geometry[1] = new THREE.Geometry();
	line_geometry[1].vertices.push(new THREE.Vector3( 0, 1000, 0) );
	line_geometry[1].vertices.push(new THREE.Vector3( 0, -1000, 0) );
	line_material[1] = new THREE.LineBasicMaterial({
		color: 0xffffff
	});
	line[1] = new THREE.Line(line_geometry[1], line_material[1]);
	scene.add(line[1]);
	
	line_geometry[2] = new THREE.Geometry();
	line_geometry[2].vertices.push(new THREE.Vector3( 0, 0, 1000) );
	line_geometry[2].vertices.push(new THREE.Vector3( 0, 0, -1000) );
	line_material[2] = new THREE.LineBasicMaterial({
		color: 0xffffff
	});
	line[2] = new THREE.Line(line_geometry[2], line_material[2]);
	scene.add(line[2]);
	
	
	/**
	* 光源设置
	*/
   
	//点光源
	var point = new THREE.PointLight(0xffffff);
	point.position.set(0, 200, 0); //点光源位置
	scene.add(point); //点光源添加到场景中
	
	//环境光
	var ambient = new THREE.AmbientLight(0x444444);
	scene.add(ambient);
	
	
	/**
	* 相机设置
	*/
	var width = window.innerWidth; //窗口宽度
	var height = window.innerHeight; //窗口高度
	var k = width / height; //窗口宽高比
	var s = 166; //三维场景显示范围控制系数，系数越大，显示的范围越大
	//创建相机对象
	camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 1000);
	camera.position.set(0, 250, 0); //设置相机位置
	camera.lookAt(scene.position); //设置相机方向(指向的场景对象)
	
	
	/**
	* 创建渲染器对象
	*/
	var renderer = new THREE.WebGLRenderer();
	renderer.setSize(width, height);//设置渲染区域尺寸
	renderer.setClearColor("#eef", 1); //设置背景颜色
	document.body.appendChild(renderer.domElement); //body元素中插入canvas对象
	renderer.domElement.style.cursor = "none";
	//执行渲染操作   指定场景、相机作为参数
	renderer.render(scene, camera);
	
	/**
	* 判断手机电脑
	*/
	if (
		!(/ipad|iphone|midp|rv:1.2.3.4|ucweb|android|windows ce|windows mobile/.test(
				navigator.userAgent.toLowerCase()
			)
		)
	){
		//电脑
		let mouse = document.createElement("div");
		let parts = [
			document.createElement("div"),	//竖
			document.createElement("div")	//横
		];
		parts[0].style.width = "2px";
		parts[0].style.height = "30px";
		parts[0].style.backgroundColor = "#fff";
		parts[0].style.position = "absolute";
		parts[0].style.left = "50%";
		parts[0].style.top = "50%";
		parts[0].style.transform = "translateY(-100%)";
		
		parts[1].style.width = "30px";
		parts[1].style.height = "2px";
		parts[1].style.backgroundColor = "#fff";
		parts[1].style.left = "50%";
		parts[1].style.top = "50%";
		
		mouse.appendChild(parts[0]);
		mouse.appendChild(parts[1]);
		mouse.style.width = "30px";
		mouse.style.height = "30px";
		mouse.style.position = "absolute";
		mouse.style.left = "50%";
		mouse.style.top = "50%";
		mouse.style.transform = "translate(-50%,-50%)";
		
		document.body.appendChild(mouse);
	}
	
	/**
	* stats
	*/
	var stats = new Stats();
	stats.showPanel(0);
	document.body.appendChild(stats.dom);
	
	var watcher = {
		v: {
			x: 0,
			y: 0,
			z: 0
		},
		pos: camera.position,
		lookAt: {
			left_right: 220,
			top_bottom: -30
		},
		look: {
			x: 1,
			y: 0,
			z: 0
		}
	};
	
	let watcher_folder = gui.addFolder("玩家");
		let watcher_position_folder = watcher_folder.addFolder("位置");
		watcher_position_folder.open();
			watcher_position_folder.add(watcher.pos, "x", -1000, 1000, 10).listen();
			watcher_position_folder.add(watcher.pos, "y", -1000, 1000, 10).listen();
			watcher_position_folder.add(watcher.pos, "z", -1000, 1000, 10).listen();
		let watcher_lookAt_folder = watcher_folder.addFolder("朝向");
		watcher_lookAt_folder.open();
			watcher_lookAt_folder.add(watcher.lookAt, "left_right", 0, 360).listen();
			watcher_lookAt_folder.add(watcher.lookAt, "top_bottom", -90, 90).listen();
		let watcher_look_folder = watcher_folder.addFolder("朝向（笛卡尔坐标系）");
		watcher_look_folder.open();
			watcher_look_folder.add(watcher.look, "x", 0, 1, 0.01).listen();
			watcher_look_folder.add(watcher.look, "y", 0, 1, 0.01).listen();
			watcher_look_folder.add(watcher.look, "z", 0, 1, 0.01).listen();
	let T0 = new Date();//上次时间
	function render() {
		let t = new Date()-T0;//时间差
		T0 = new Date();//把本次时间赋值给上次时间
		requestAnimationFrame(render);
		renderer.render(scene, camera);//执行渲染操作
		
		let x =
			Math.cos(watcher.lookAt.left_right/180*Math.PI)*
			Math.cos(watcher.lookAt.top_bottom/180*Math.PI)
		;
		let z =
			Math.sin(watcher.lookAt.left_right/180*Math.PI)*
			Math.cos(watcher.lookAt.top_bottom/180*Math.PI)
		;
		let y = Math.sin(watcher.lookAt.top_bottom/180*Math.PI);
		camera.lookAt(watcher.pos.x+x, watcher.pos.y+y, watcher.pos.z+z);
		watcher.look.x = x;
		watcher.look.y = y;
		watcher.look.z = z;
		point.position.x = watcher.pos.x;
		point.position.y = watcher.pos.y;
		point.position.z = watcher.pos.z;
		
		let h = new Date().getHours();
		if (h > 20 | h < 5){ // 天黑
			renderer.setClearColor("#334", 1);
		}else if (h > 18 | h < 7){ // 日出/日落
			renderer.setClearColor("#d34", 1);
		}else{
			renderer.setClearColor("#eef", 1);
		}
		
		stats.update();
	}
	// render();
	// 间隔30ms周期性调用函数fun
	//setInterval("render()",16.7)

	/* var controls = new THREE.OrbitControls(camera,renderer.domElement);//创建控件对象
	controls.addEventListener('change', render);//监听鼠标、键盘事件 */

	document.onkeydown = function (e){
		console.log(e.keyCode);
		let x=0, y=0, z=0;
		if (e.keyCode == 87 | e.keyCode == 38){ //前
			x =
				Math.cos( (watcher.lookAt.left_right+0) /180*Math.PI)*
				Math.cos( (watcher.lookAt.top_bottom+0) /180*Math.PI)
			;
			z =
				Math.sin( (watcher.lookAt.left_right+0) /180*Math.PI)*
				Math.cos( (watcher.lookAt.top_bottom+0) /180*Math.PI)
			;
		}
		if (e.keyCode == 83 | e.keyCode == 40){ //后
			x =
				Math.cos( (watcher.lookAt.left_right+180) /180*Math.PI)*
				Math.cos( (watcher.lookAt.top_bottom+0) /180*Math.PI)
			;
			z =
				Math.sin( (watcher.lookAt.left_right+180) /180*Math.PI)*
				Math.cos( (watcher.lookAt.top_bottom+0) /180*Math.PI)
			;
		}
		if (e.keyCode == 65 | e.keyCode == 37){ //左
			x =
				Math.cos( (watcher.lookAt.left_right-90) /180*Math.PI)*
				Math.cos( (watcher.lookAt.top_bottom+0) /180*Math.PI)
			;
			z =
				Math.sin( (watcher.lookAt.left_right-90) /180*Math.PI)*
				Math.cos( (watcher.lookAt.top_bottom+0) /180*Math.PI)
			;
		}
		if (e.keyCode == 68 | e.keyCode == 39){ //右
			x =
				Math.cos( (watcher.lookAt.left_right+90) /180*Math.PI)*
				Math.cos( (watcher.lookAt.top_bottom+0) /180*Math.PI)
			;
			z =
				Math.sin( (watcher.lookAt.left_right+90) /180*Math.PI)*
				Math.cos( (watcher.lookAt.top_bottom+0) /180*Math.PI)
			;
		}
		if (e.keyCode == 32){ //上
			y = 1;
		}
		if (e.keyCode == 16){ //下
			y = -1;
		}
		watcher.pos.x += x*10;
		watcher.pos.y += y*10;
		watcher.pos.z += z*10;
	}
	
	
	let x0 = null, y0 = null;
	$("canvas:eq(0)").on("mousemove", function (e){
		var x = e.pageX;
		var y = e.pageY;
		console.log("mousemove:", x, y);
		
		if ( Math.sqrt(Math.pow(x-x0,2)+Math.pow(y-y0,2)) <= 100 & x0 !== null & y0 !== null ){
			let [dx, dy] = [x-x0, y-y0];
			[x0, y0] = [x, y];
			console.log(dx, dy);
			watcher.lookAt.left_right += dx/document.getElementsByTagName("canvas")[0].offsetWidth*360;
			watcher.lookAt.top_bottom -= dy/document.getElementsByTagName("canvas")[0].offsetHeight*360;
			
			if (watcher.lookAt.left_right > 360)
				while (watcher.lookAt.left_right > 360)
					watcher.lookAt.left_right -= 360;
			if (watcher.lookAt.left_right < 0)
				while (watcher.lookAt.left_right < 0)
					watcher.lookAt.left_right += 360;
			
			if (watcher.lookAt.top_bottom > 90)
				watcher.lookAt.top_bottom = 90;
			if (watcher.lookAt.top_bottom < -90)
				watcher.lookAt.top_bottom = -90;
			
		}
		
		[x0,y0] = [x, y];
	});
	
	$("canvas:eq(0)").on("touchstart", function (e){
		var x = e.originalEvent.touches[0].pageX;
		var y = e.originalEvent.touches[0].pageY;
		console.log("touchstart:", x, y);
		
		[x0,y0] = [x, y];
	});
	$("canvas:eq(0)").on("touchmove", function (e){
		if (x0 === null | y0 === null)
			return;
		
		var x = e.originalEvent.touches[0].pageX;
		var y = e.originalEvent.touches[0].pageY;
		console.log("touchmove:", x, y);
		
		let [dx, dy] = [x-x0, y-y0];
		[x0, y0] = [x, y];
		console.log(dx, dy);
		watcher.lookAt.left_right -= dx/document.getElementsByTagName("canvas")[0].offsetWidth*90;
		watcher.lookAt.top_bottom += dy/document.getElementsByTagName("canvas")[0].offsetHeight*90;
		
		if (watcher.lookAt.left_right > 360)
			while (watcher.lookAt.left_right > 360)
				watcher.lookAt.left_right -= 360;
		if (watcher.lookAt.left_right < 0)
			while (watcher.lookAt.left_right < 0)
				watcher.lookAt.left_right += 360;
		
		if (watcher.lookAt.top_bottom > 90)
			watcher.lookAt.top_bottom = 90;
		if (watcher.lookAt.top_bottom < -90)
			watcher.lookAt.top_bottom = -90;
		
	});
	$("canvas:eq(0)").on('touchend', function (e){
		console.log("touchend");
		
		x0 = null, y0 = null;
	});
	$("canvas:eq(0)").on('touchcancel', function (e){
		console.log("touchcancel");
		
		x0 = null, y0 = null;
	});
	
	
	let raycaster = new THREE.Raycaster();//光线投射，用于确定鼠标点击位置
	let mouse = new THREE.Vector2();//创建二维平面
	window.addEventListener("mousedown", function (e){
		//将html坐标系转化为webgl坐标系，并确定鼠标点击位置
		mouse.x = 0;
		mouse.y = 0;
		//以camera为z坐标，确定所点击物体的3D空间位置
		raycaster.setFromCamera(mouse,camera);
		//确定所点击位置上的物体数量
		let intersects = raycaster.intersectObjects(scene.children);
		//选中后进行的操作
		if(intersects.length){
			debugger;
		}
	});
}

//屏蔽选择文字
document.onselectstart = function (){
	return false;
};
</script>
	</body>
</html>