<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
		<title>我的世界（电脑版）</title>
		<style>
			body{
				margin: 0;
				overflow: hidden;
				/* 隐藏body窗口区域滚动条 */
			}
			#loading{
				position: absolute;
				width: 100%;
				height: 100%;
				margin: 0;
				padding-top: 20%;
				text-align: center;
				color: #fff;
				background-color: #000;
			}
		</style>
		<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
		<script src="./node_modules/stats.js/build/stats.min.js"></script>
		<script src="./node_modules/dat.gui/build/dat.gui.min.js"></script>
		<script src="./node_modules/three/build/three.min.js"></script>
		<script src="./node_modules/three/examples/js/controls/PointerLockControls.js"></script>
	</head>

	<body>
		<h1 id="loading">
			<span id="schedule_message">贴图加载中……</span><br/>
			主进度：<span id="schedule1">0</span>%<br/>
			次进度：<span id="schedule2">0</span>%
		</h1>
<script>
/**
* 初始化
*/
var stop = false;
const blocks = [
	{
		name: "空气",
		texture: []
	},
	{
		name: "草方块",
		texture: []
	},
	{
		name: "木板",
		texture: []
	},
	{
		name: "石头",
		texture: []
	}
];
const every = [];
for (let x=-10; x<=10; x++){
	every[x] = [];
	for (let y=0; y<=20; y++){
		every[x][y] = [];
		for (let z=-10; z<=10; z++){
			if (y == 0){
				if (x < 0){
					every[x][y][z] = 1;
				}else if (x > 6){
					every[x][y][z] = 2;
				}else{
					every[x][y][z] = 3;
				}
			}else{
				every[x][y][z] = 0;
			}
		}
	}
}


/**
* dat.gui
*/
let gui = new dat.GUI({
	name: "信息",
	useLocalStorage: false, // 使用LocalStorage来存储
	closeOnTop: true // 关闭按钮是否在顶部
});

/**
* 创建场景对象Scene
*/
let scene = new THREE.Scene();
scene.fog = new THREE.Fog( 0xffffff, 0.01, 5000); //雾气颜色，近处的距离， 远处的距离

/**
* 创建网格模型
*/
let block_geometry = new THREE.BoxGeometry(100, 100, 100);
// TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理
let textureLoader = new THREE.TextureLoader();
let num = 0;
for (let i in blocks){
	for (let j=1; j<=6; j++){
		textureLoader.load(`./img/blocks/${blocks[i].name}/${j}.png`, function (texture){
			blocks[i].texture[j] = texture;
			
			if (blocks[i].texture.length < 7)
				return;
			//单个block加载完毕
			for (let k=1;k<blocks[i].texture.length;k++)
				if (blocks[i].texture[k] == undefined)
					return;
			blocks[i].material = [
				new THREE.MeshLambertMaterial({ map: blocks[i].texture[1] }),
				new THREE.MeshLambertMaterial({ map: blocks[i].texture[2] }),
				new THREE.MeshLambertMaterial({ map: blocks[i].texture[3] }),
				new THREE.MeshLambertMaterial({ map: blocks[i].texture[4] }),
				new THREE.MeshLambertMaterial({ map: blocks[i].texture[5] }),
				new THREE.MeshLambertMaterial({ map: blocks[i].texture[6] })
			]; //材质对象Material
			document.getElementById("schedule2").innerHTML = Math.round(i/6*100*100)/100;
			
			for (let k in blocks)
				if (blocks[k].material == undefined)
					return;
			//所有block加载完毕
			document.getElementById("schedule_message").innerHTML = "载入方块中……";
			document.getElementById("schedule1").innerHTML = "50";
			x = -10;
			loop = setInterval(function (){
				for (let y=0; y<=20; y++){
					for (let z=-10; z<=10; z++){
						document.getElementById("schedule2").innerHTML = Math.round((x+10)/20*100*100)/100;
						if (every[x][y][z] != 0){ //非真空
							let mesh = new THREE.Mesh(block_geometry, blocks[ every[x][y][z] ].material); //网格模型对象Mesh
							mesh.position.x = x*100;
							mesh.position.y = y*100;
							mesh.position.z = z*100;
							scene.add(mesh); //网格模型添加到场景中
						}
					}
				}
				
				x++;
				console.log("loading:", x);
				if (x > 10){
					console.log("achieve loading");
					document.getElementById("schedule1").innerHTML = "100";
					//纹理贴图加载成功后，调用渲染函数执行渲染操作
					render();
					document.getElementById("loading").remove();
					clearInterval(loop);
					delete loop;
					delete x;
				}
				
				
				/* for (let x=-10;x<=10;x++){
					console.log("loading:", x);
					for (let y=0;y<=20;y++){
						for (let z=-10;z<=10;z++){
							document.getElementById("schedule1").innerHTML = Math.round(x/20*100*100)/100;
							document.getElementById("schedule2").innerHTML = Math.round(y/20*100*100)/100;
							if (every[x][y][z] == 0) //空气
								continue;
							let mesh = new THREE.Mesh(block_geometry, blocks[ every[x][y][z] ].material); //网格模型对象Mesh
							mesh.position.x = x*100;
							mesh.position.y = y*100;
							mesh.position.z = z*100;
							scene.add(mesh); //网格模型添加到场景中
						}
					}
				}
				//纹理贴图加载成功后，调用渲染函数执行渲染操作
				render();
				document.getElementById("loading").remove(); */
			},0);
		});
	}
}

/* let floor_geometry = new THREE.PlaneGeometry(1000, 1000, 6, 6);
let floor_material = new THREE.MeshBasicMaterial({ color:"#fff"});
//floor_material.wireframe = true; //仅框架
floor_mesh = new THREE.Mesh(floor_geometry, floor_material);
// 由于平地添加后默认是在正前方 所以需要旋转一下
floor_mesh.rotation.x = -0.5 * Math.PI;
floor_mesh.position.y = -10;
scene.add(floor_mesh); */


let line = [];
let line_geometry = [];
let line_material = [];

line_geometry[0] = new THREE.Geometry();
line_geometry[0].vertices.push(new THREE.Vector3( -1000, 0, 0) );
line_geometry[0].vertices.push(new THREE.Vector3( 1000, 0, 0) );
line_material[0] = new THREE.LineBasicMaterial({
	color: 0xffffff
});
line[0] = new THREE.Line(line_geometry[0], line_material[0]);
scene.add(line[0]);

line_geometry[1] = new THREE.Geometry();
line_geometry[1].vertices.push(new THREE.Vector3( 0, 1000, 0) );
line_geometry[1].vertices.push(new THREE.Vector3( 0, -1000, 0) );
line_material[1] = new THREE.LineBasicMaterial({
	color: 0xffffff
});
line[1] = new THREE.Line(line_geometry[1], line_material[1]);
scene.add(line[1]);

line_geometry[2] = new THREE.Geometry();
line_geometry[2].vertices.push(new THREE.Vector3( 0, 0, 1000) );
line_geometry[2].vertices.push(new THREE.Vector3( 0, 0, -1000) );
line_material[2] = new THREE.LineBasicMaterial({
	color: 0xffffff
});
line[2] = new THREE.Line(line_geometry[2], line_material[2]);
scene.add(line[2]);


/**
* 光源设置
*/

//点光源
let point = new THREE.PointLight(0xffffff);
point.position.set(0, 200, 0); //点光源位置
scene.add(point); //点光源添加到场景中

//环境光
let ambient = new THREE.AmbientLight(0x444444);
scene.add(ambient);


/**
* 相机设置
*/
/* let width = window.innerWidth; //窗口宽度
let height = window.innerHeight; //窗口高度
let k = width / height; //窗口宽高比
let s = 1000; //三维场景显示范围控制系数，系数越大，显示的范围越大
//创建相机对象
let camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 1000);
camera.position.set(0, 200, 0); //设置相机位置
camera.lookAt(scene.position); //设置相机方向(指向的场景对象) */


let width = window.innerWidth,
	height = window.innerHeight;
let camera = new THREE.PerspectiveCamera(45, width/height, 1, 2000);
//								 view_angle, aspect, near, far
camera.position.set(0, 200, 0); //设置相机位置
camera.lookAt(scene.position); //设置相机方向(指向的场景对象)

/**
* 创建渲染器对象
*/
let renderer = new THREE.WebGLRenderer();
renderer.setSize(width, height);//设置渲染区域尺寸
renderer.setClearColor("#eef", 1); //设置背景颜色
document.body.appendChild(renderer.domElement); //body元素中插入canvas对象
renderer.domElement.style.cursor = "none";
//执行渲染操作   指定场景、相机作为参数
renderer.render(scene, camera);

/**
* 判断手机电脑
*/
if (
	!(/ipad|iphone|midp|rv:1.2.3.4|ucweb|android|windows ce|windows mobile/.test(
			navigator.userAgent.toLowerCase()
		)
	)
){
	//电脑
	let mouse = document.createElement("div");
	let parts = [
		document.createElement("div"),	//竖
		document.createElement("div")	//横
	];
	parts[0].style.width = "2px";
	parts[0].style.height = "30px";
	parts[0].style.backgroundColor = "#ffffffaa";
	parts[0].style.position = "absolute";
	parts[0].style.left = "50%";
	parts[0].style.top = "50%";
	parts[0].style.transform = "translate(-50%,-50%)";
	
	parts[1].style.width = "30px";
	parts[1].style.height = "2px";
	parts[1].style.backgroundColor = "#ffffffaa";
	parts[1].style.position = "absolute";
	parts[1].style.left = "50%";
	parts[1].style.top = "50%";
	parts[1].style.transform = "translate(-50%,-50%)";
	
	mouse.appendChild(parts[0]);
	mouse.appendChild(parts[1]);
	mouse.style.width = "30px";
	mouse.style.height = "30px";
	mouse.style.position = "absolute";
	mouse.style.left = "50%";
	mouse.style.top = "50%";
	mouse.style.transform = "translate(-50%,-50%)";
	mouse.id = "mouse";
	mouse.style.cursor = "none";
	
	document.body.appendChild(mouse);
}

/**
* stats
*/
let stats = new Stats();
stats.showPanel(0);
document.body.appendChild(stats.dom);

let watcher = {
	v: {
		x: 0,
		y: 0,
		z: 0
	},
	pos: camera.position,
	lookAt: {
		left_right: 220,
		top_bottom: -30
	},
	look: {
		x: 1,
		y: 0,
		z: 0
	}
};

let watcher_folder = gui.addFolder("玩家");
watcher_folder.open();
	watcher_folder.add(window, "stop").listen();
	let watcher_position_folder = watcher_folder.addFolder("位置/像素");
	watcher_position_folder.open();
		watcher_position_folder.add(watcher.pos, "x", -1000, 1000, 10).listen();
		watcher_position_folder.add(watcher.pos, "y", -1000, 1000, 10).listen();
		watcher_position_folder.add(watcher.pos, "z", -1000, 1000, 10).listen();
	let watcher_lookAt_folder = watcher_folder.addFolder("朝向（球坐标系）");
		watcher_lookAt_folder.add(watcher.lookAt, "left_right", 0, 360).listen();
		watcher_lookAt_folder.add(watcher.lookAt, "top_bottom", -90, 90).listen();
	let watcher_look_folder = watcher_folder.addFolder("朝向（笛卡尔坐标系）");
	watcher_look_folder.open();
		watcher_look_folder.add(watcher.look, "x", 0, 1, 0.01).listen();
		watcher_look_folder.add(watcher.look, "y", 0, 1, 0.01).listen();
		watcher_look_folder.add(watcher.look, "z", 0, 1, 0.01).listen();
let T0 = new Date();//上次时间
function render() {
	let t = new Date()-T0;//时间差
	T0 = new Date();//把本次时间赋值给上次时间
	requestAnimationFrame(render);
	renderer.render(scene, camera);//执行渲染操作
	
	let x =
		Math.cos(watcher.lookAt.left_right/180*Math.PI)*
		Math.cos(watcher.lookAt.top_bottom/180*Math.PI)
	;
	let z =
		Math.sin(watcher.lookAt.left_right/180*Math.PI)*
		Math.cos(watcher.lookAt.top_bottom/180*Math.PI)
	;
	let y = Math.sin(watcher.lookAt.top_bottom/180*Math.PI);
	camera.lookAt(watcher.pos.x+x, watcher.pos.y+y, watcher.pos.z+z);
	watcher.look.x = x;
	watcher.look.y = y;
	watcher.look.z = z;
	point.position.x = watcher.pos.x;
	point.position.y = watcher.pos.y;
	point.position.z = watcher.pos.z;
	
	let h = new Date().getHours();
	if (h > 20 | h < 5){ // 天黑
		renderer.setClearColor("#334", 1);
	}else if (h > 18 | h < 7){ // 日出/日落
		renderer.setClearColor("#b23", 1);
	}else{
		renderer.setClearColor("#eef", 1);
	}
	
	stats.update();
}
// render();
// 间隔30ms周期性调用函数fun
//setInterval("render()",16.7)

/* let controls = new THREE.OrbitControls(camera,renderer.domElement);//创建控件对象
controls.addEventListener('change', render);//监听鼠标、键盘事件 */

document.onkeydown = function (e){
	if (e.keyCode == 27){
		stop = !stop;
		$("canvas:eq(0),#mouse").css("cursor",stop?"default":"none");
		return;
	}
	let x=0, y=0, z=0;
	switch (e.keyCode){
		case 87:
		case 38: //前
			console.log("front:", e.keyCode);
			x =
				Math.cos( (watcher.lookAt.left_right+0) /180*Math.PI)
			;
			z =
				Math.sin( (watcher.lookAt.left_right+0) /180*Math.PI)
			;
			break;
		case 83:
		case 40: //后
			console.log("behind:", e.keyCode);
			x =
				Math.cos( (watcher.lookAt.left_right+180) /180*Math.PI)
			;
			z =
				Math.sin( (watcher.lookAt.left_right+180) /180*Math.PI)
			;
			break;
		case 65:
		case 37: //左
			console.log("left:", e.keyCode);
			x =
				Math.cos( (watcher.lookAt.left_right-90) /180*Math.PI)
			;
			z =
				Math.sin( (watcher.lookAt.left_right-90) /180*Math.PI)
			;
			break;
		case 68:
		case 39: //右
			console.log("right:", e.keyCode);
			x =
				Math.cos( (watcher.lookAt.left_right+90) /180*Math.PI)
			;
			z =
				Math.sin( (watcher.lookAt.left_right+90) /180*Math.PI)
			;
			break;
		case 32: //上
			console.log("up:", e.keyCode);
			y = 1;
			break;
		case 16: //下
			console.log("down:", e.keyCode);
			y = -1;
			break;
		case 121: //F10
			if (gui.closed){
				gui.open();
			}else{
				gui.close();
			}
		default:
			console.log("keydown:", e.keyCode);
			break;
	}
	watcher.pos.x += x*10;
	watcher.pos.y += y*10;
	watcher.pos.z += z*10;
}


/* let choice_object = get_choice_object()?get_choice_object()[1]:undefined;

let choice_folder = gui.addFolder("选择物体");
choice_folder.open();
	choice_position_folder = choice_folder.addFolder("位置");
	choice_position_folder.open();
		choice_position_folder.add(choice_object?choice_object.object.position:{x:0,y:0,z:0}, "x", -1000, 1000, 100).listen();
		choice_position_folder.add(choice_object?choice_object.object.position:{x:0,y:0,z:0}, "y", -1000, 1000, 100).listen();
		choice_position_folder.add(choice_object?choice_object.object.position:{x:0,y:0,z:0}, "z", -1000, 1000, 100).listen();
	choice_folder.add(choice_object.faceIndex?choice_object:{faceIndex:-1}, "faceIndex", 0, 12).listen(); */
let x0 = null, y0 = null;
$("body").on("mousemove", function (e){
	if (stop)
		return;
	
	let x = e.pageX;
	let y = e.pageY;
	console.log("mousemove:", x, y);
	if (get_choice_object()){
		for (let i=0; i<get_choice_object().length; i++){
			console.log("choice_block", get_choice_object()[i].object.position, get_choice_object()[i].faceIndex);
		}
	}
	
	// choice_object = get_choice_object()?get_choice_object()[1]:undefined;
	
	if ( Math.sqrt(Math.pow(x-x0,2)+Math.pow(y-y0,2)) <= 100 & x0 !== null & y0 !== null ){
		let [dx, dy] = [x-x0, y-y0];
		[x0, y0] = [x, y];
		console.log("move:", dx, dy);
		watcher.lookAt.left_right += dx/document.getElementsByTagName("canvas")[0].offsetWidth*360;
		watcher.lookAt.top_bottom -= dy/document.getElementsByTagName("canvas")[0].offsetHeight*360;
		
		if (watcher.lookAt.left_right > 360)
			while (watcher.lookAt.left_right > 360)
				watcher.lookAt.left_right -= 360;
		if (watcher.lookAt.left_right < 0)
			while (watcher.lookAt.left_right < 0)
				watcher.lookAt.left_right += 360;
		
		if (watcher.lookAt.top_bottom > 90)
			watcher.lookAt.top_bottom = 90;
		if (watcher.lookAt.top_bottom < -90)
			watcher.lookAt.top_bottom = -90;
		
	}
	
	[x0,y0] = [x, y];
});

$("canvas:eq(0)").on("mousedown", function (e){
	if (stop)
		return;
	
	if (e.button == 0){ //左键（删除）
		let click = get_choice_object();
		for (let i in click){
			if (click[i].faceIndex){
				if (click[i].object instanceof THREE.Mesh){
					if (Math.sqrt(
						Math.pow(click[i].object.position.x - watcher.pos.x, 2)+
						Math.pow(click[i].object.position.y - watcher.pos.y, 2)+
						Math.pow(click[i].object.position.z - watcher.pos.z, 2)
					) < 500){ //距离小于500
						console.log("delete:", click[i].object.position);
						scene.remove(click[i].object);
						break;
					}
				}
			}
		}
	}else if (e.button == 2){ //右键（放置）
		let click = get_choice_object();
		for (let i in click){
			if (click[i].object instanceof THREE.Mesh){
				if (Math.sqrt(
					Math.pow(click[i].object.position.x - watcher.pos.x, 2)+
					Math.pow((click[i].object.position.y+100) - watcher.pos.y, 2)+
					Math.pow(click[i].object.position.z - watcher.pos.z, 2)
				) < 500){ //距离小于500
					if (click[i].faceIndex == 4 | click[i].faceIndex == 5){ //上
						let mesh = new THREE.Mesh(block_geometry, blocks[3].material); //石头
						mesh.position.x = click[i].object.position.x;
						mesh.position.y = click[i].object.position.y+100;
						mesh.position.z = click[i].object.position.z;
						scene.add(mesh); //网格模型添加到场景中
						break;
					}
				}
			}
		}
	}
	return false;
})


/**
* Touch
*/
$("body").on("touchstart", function (e){
	if (stop)
		return;
	
	let x = e.originalEvent.touches[0].pageX;
	let y = e.originalEvent.touches[0].pageY;
	console.log("touchstart:", x, y);
	
	[x0,y0] = [x, y];
});
$("body").on("touchmove", function (e){
	if (stop)
		return;
	
	if (x0 === null | y0 === null)
		return;
	
	let x = e.originalEvent.touches[0].pageX;
	let y = e.originalEvent.touches[0].pageY;
	console.log("touchmove:", x, y);
	
	let [dx, dy] = [x-x0, y-y0];
	[x0, y0] = [x, y];
	console.log("move:", dx, dy);
	watcher.lookAt.left_right -= dx/document.getElementsByTagName("canvas")[0].offsetWidth*90;
	watcher.lookAt.top_bottom += dy/document.getElementsByTagName("canvas")[0].offsetHeight*90;
	
	if (watcher.lookAt.left_right > 360)
		while (watcher.lookAt.left_right > 360)
			watcher.lookAt.left_right -= 360;
	if (watcher.lookAt.left_right < 0)
		while (watcher.lookAt.left_right < 0)
			watcher.lookAt.left_right += 360;
	
	if (watcher.lookAt.top_bottom > 90)
		watcher.lookAt.top_bottom = 90;
	if (watcher.lookAt.top_bottom < -90)
		watcher.lookAt.top_bottom = -90;
	
});
$("body").on('touchend', function (e){
	if (stop)
		return;
	
	console.log("touchend");
	
	x0 = null, y0 = null;
});
$("body").on('touchcancel', function (e){
	if (stop)
		return;
	
	console.log("touchcancel");
	
	x0 = null, y0 = null;
});


function get_choice_object(){
	let raycaster = new THREE.Raycaster(); //光线投射，用于确定鼠标点击位置
	let mouse = new THREE.Vector2(); //创建二维平面
	mouse.x = 0;
	mouse.y = 0;
	//以camera为z坐标，确定所点击物体的3D空间位置
	raycaster.setFromCamera(mouse,camera);
	//确定所点击位置上的物体数量
	let intersects = raycaster.intersectObjects(scene.children);
	//选中后进行的操作
	if(intersects.length){
		return intersects;
		/* console.log(
			intersects[1].object.position,
			intersects[1].faceIndex
		); */
	}
	return undefined;
}

//屏蔽鼠标右键
document.oncontextmenu = function (e){
	//var e = e || window.event;
	//e.returnValue = false;
	return false;
};
//屏蔽选择文字
document.onselectstart = function (){
	return false;
};
</script>
	</body>
</html>