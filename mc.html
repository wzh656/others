<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>我的世界</title>
		<style>
			body{
				margin: 0;
				overflow: hidden;
				/* 隐藏body窗口区域滚动条 */
			}
			#loading{
				position: absolute;
				width: 100%;
				height: 100%;
				margin: 0;
				padding-top: 20%;
				text-align: center;
				color: #fff;
				background-color: #000;
			}
		</style>
		<script src="./node_modules/stats.js/build/stats.min.js"></script>
		<script src="./node_modules/dat.gui/build/dat.gui.min.js"></script>
		<script src="./node_modules/three/build/three.min.js"></script>
		<script src="./node_modules/three/examples/js/controls/OrbitControls.js"></script>
	</head>

	<body>
		<h1 id="loading">贴图加载中……（<span id="schedule">0</span>%）</h1>
<script>
var scene, camera;
window.onload = function (){
	/**
	* 创建场景对象Scene
	*/
	scene = new THREE.Scene();

	/**
	* 创建网格模型
	*/
	/* var geometry = new THREE.BoxGeometry(100, 200, 300); //创建一个立方体几何对象Geometry
	var material = new THREE.MeshLambertMaterial({
	color: 0x66ff88
	}); //材质对象Material
	var mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh
	mesh.position.x = 1;
	scene.add(mesh); //网格模型添加到场景中 */
	
	// 纹理贴图映射到一个矩形平面上
	
	/* var material = new THREE.MeshPhongMaterial({
		map: THREE.ImageUtils.loadTexture('./img/block/草方块.png')
	}); */
	/* geometry.faceVertexUvs[0] = [];
	let top = [
		new THREE.Vector2(0/2, 2/3),
		new THREE.Vector2(1/2, 2/3),
		new THREE.Vector2(1/2, 3/3),
		new THREE.Vector2(0/2, 3/3)
	];
	let bottom = [
		new THREE.Vector2(1/2, 2/3),
		new THREE.Vector2(2/2, 2/3),
		new THREE.Vector2(2/2, 3/3),
		new THREE.Vector2(1/2, 3/3)
	];
	let left = [
		new THREE.Vector2(0/2, 1/3),
		new THREE.Vector2(1/2, 1/3),
		new THREE.Vector2(1/2, 2/3),
		new THREE.Vector2(0/2, 2/3)
	];
	let right = [
		new THREE.Vector2(1/2, 1/3),
		new THREE.Vector2(2/2, 1/3),
		new THREE.Vector2(2/2, 2/3),
		new THREE.Vector2(1/2, 2/3)
	];
	let front = [
		new THREE.Vector2(0/2, 0/3),
		new THREE.Vector2(1/2, 0/3),
		new THREE.Vector2(1/2, 1/3),
		new THREE.Vector2(0/2, 1/3)
	];
	let behind = [
		new THREE.Vector2(1/2, 0/3),
		new THREE.Vector2(2/2, 0/3),
		new THREE.Vector2(2/2, 1/3),
		new THREE.Vector2(1/2, 1/3)
	];
	geometry.faceVertexUvs[0][0] = [ top[0], top[1], top[3] ];
	geometry.faceVertexUvs[0][1] = [ top[1], top[2], top[3] ];
	
	geometry.faceVertexUvs[0][2] = [ bottom[0], bottom[1], bottom[3] ];
	geometry.faceVertexUvs[0][3] = [ bottom[1], bottom[2], bottom[3] ];
	
	geometry.faceVertexUvs[0][4] = [ left[0], left[1], left[3] ];
	geometry.faceVertexUvs[0][5] = [ left[1], left[2], left[3] ];
	
	geometry.faceVertexUvs[0][6] = [ right[0], right[1], right[3] ];
	geometry.faceVertexUvs[0][7] = [ right[1], right[2], right[3] ];
	
	geometry.faceVertexUvs[0][8] = [ front[0], front[1], front[3] ];
	geometry.faceVertexUvs[0][9] = [ front[1], front[2], front[3] ];
	
	geometry.faceVertexUvs[0][10] = [ behind[0], behind[1], behind[3] ];
	geometry.faceVertexUvs[0][11] = [ behind[1], behind[2], behind[3] ];
	
	var meshFaceMaterial = new THREE.MeshFaceMaterial( material );
	mesh = new THREE.Mesh(geometry,  meshFaceMaterial); */
	var geometry = new THREE.BoxGeometry(100, 100, 100);
	// TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理
	var textureLoader = new THREE.TextureLoader();
	var block = [];
	for (var i=1;i<=6;i++){
		// 执行load方法，加载纹理贴图成功后，返回一个纹理对象Texture
		textureLoader.load(`./img/block/草方块/${i}.png`, function (texture){
			block.push(texture);
			document.getElementById("schedule").innerHTML = Math.round(block.length/6*100*100)/100;
			if (block.length == 6){
				block.sort((value) => {
					return value.id;
				}); //排序防止混乱
				document.getElementById("loading").remove();
				var material = [
					new THREE.MeshLambertMaterial({ map: block[0] }),
					new THREE.MeshLambertMaterial({ map: block[1] }),
					new THREE.MeshLambertMaterial({ map: block[2] }),
					new THREE.MeshLambertMaterial({ map: block[3] }),
					new THREE.MeshLambertMaterial({ map: block[4] }),
					new THREE.MeshLambertMaterial({ map: block[5] })
				]; //材质对象Material
				for (let i=-5;i<=5;i++){
					for (let j=-5;j<5;j++){
						console.log(i,j);
						let mesh = new THREE.Mesh(geometry, material); //网格模型对象Mesh
						mesh.position.x = i*100;
						mesh.position.z = j*100;
						scene.add(mesh); //网格模型添加到场景中
					}
				}
				
				//纹理贴图加载成功后，调用渲染函数执行渲染操作
				render();
			}
			
		});
	}
	
	/* var floor_geometry = new THREE.PlaneGeometry(1000, 1000, 6, 6);
	var floor_material = new THREE.MeshBasicMaterial({ color:"#66ff88"});
	//floor_material.wireframe = true; //仅框架
	floor_mesh = new THREE.Mesh(floor_geometry, floor_material);
	// 由于平地添加后默认是在正前方 所以需要旋转一下
	floor_mesh.rotation.x = -0.5 * Math.PI;
	floor_mesh.position.y = -10;
	scene.add(floor_mesh); */
	
	
	var line = [];
	var line_geometry = [];
	var line_material = [];
	
	line_geometry[0] = new THREE.Geometry();
	line_geometry[0].vertices.push(new THREE.Vector3( -1000, 0, 0) );
	line_geometry[0].vertices.push(new THREE.Vector3( 1000, 0, 0) );
	line_material[0] = new THREE.LineBasicMaterial({
		color: 0xffffff
	});
	line[0] = new THREE.Line(line_geometry[0], line_material[0]);
	scene.add(line[0]);
	
	line_geometry[1] = new THREE.Geometry();
	line_geometry[1].vertices.push(new THREE.Vector3( 0, 1000, 0) );
	line_geometry[1].vertices.push(new THREE.Vector3( 0, -1000, 0) );
	line_material[1] = new THREE.LineBasicMaterial({
		color: 0xffffff
	});
	line[1] = new THREE.Line(line_geometry[1], line_material[1]);
	scene.add(line[1]);
	
	line_geometry[2] = new THREE.Geometry();
	line_geometry[2].vertices.push(new THREE.Vector3( 0, 0, 1000) );
	line_geometry[2].vertices.push(new THREE.Vector3( 0, 0, -1000) );
	line_material[2] = new THREE.LineBasicMaterial({
		color: 0xffffff
	});
	line[2] = new THREE.Line(line_geometry[2], line_material[2]);
	scene.add(line[2]);
	
	
	/**
	* 光源设置
	*/
   
	//点光源
	var point = new THREE.PointLight(0xffffff);
	point.position.set(0, 200, 0); //点光源位置
	scene.add(point); //点光源添加到场景中
	
	//环境光
	var ambient = new THREE.AmbientLight(0x444444);
	scene.add(ambient);
	
	
	/**
	* 相机设置
	*/
	var width = window.innerWidth; //窗口宽度
	var height = window.innerHeight; //窗口高度
	var k = width / height; //窗口宽高比
	var s = 166; //三维场景显示范围控制系数，系数越大，显示的范围越大
	//创建相机对象
	camera = new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 1000);
	camera.position.set(0, 250, 0); //设置相机位置
	camera.lookAt(scene.position); //设置相机方向(指向的场景对象)
	
	
	/**
	* 创建渲染器对象
	*/
	var renderer = new THREE.WebGLRenderer();
	renderer.setSize(width, height);//设置渲染区域尺寸
	renderer.setClearColor(0x000000, 1); //设置背景颜色
	document.body.appendChild(renderer.domElement); //body元素中插入canvas对象
	//执行渲染操作   指定场景、相机作为参数
	renderer.render(scene, camera);

	var stats = new Stats();
	stats.showPanel(0);
	document.body.appendChild(stats.dom);

	var watcher = {
		v: {
			x: 0,
			y: 0,
			z: 0
		},
		pos: camera.position,
		lookAt: {
			left_right: 220,
			top_bottom: -30
		}
	};

	let T0 = new Date();//上次时间
	function render() {
		let t = new Date()-T0;//时间差
		T0 = new Date();//把本次时间赋值给上次时间
		requestAnimationFrame(render);
		renderer.render(scene, camera);//执行渲染操作
		
		let x =
			Math.cos(watcher.lookAt.left_right/180*Math.PI)*
			Math.cos(watcher.lookAt.top_bottom/180*Math.PI)
		;
		let z =
			Math.sin(watcher.lookAt.left_right/180*Math.PI)*
			Math.cos(watcher.lookAt.top_bottom/180*Math.PI)
		;
		let y = Math.sin(watcher.lookAt.top_bottom/180*Math.PI);
		camera.lookAt(watcher.pos.x+x, watcher.pos.y+y, watcher.pos.z+z);
		point.position.x = watcher.pos.x;
		point.position.y = watcher.pos.y;
		point.position.z = watcher.pos.z;
		
		stats.update();
	}
	// render();
	// 间隔30ms周期性调用函数fun
	//setInterval("render()",16.7)

	/* var controls = new THREE.OrbitControls(camera,renderer.domElement);//创建控件对象
	controls.addEventListener('change', render);//监听鼠标、键盘事件 */

	document.onkeydown = function (e){
		console.log(e.keyCode);
		let x=0, y=0, z=0;
		if (e.keyCode == 87 | e.keyCode == 38){ //前
			x =
				Math.cos( (watcher.lookAt.left_right+0) /180*Math.PI)*
				Math.cos( (watcher.lookAt.top_bottom+0) /180*Math.PI)
			;
			z =
				Math.sin( (watcher.lookAt.left_right+0) /180*Math.PI)*
				Math.cos( (watcher.lookAt.top_bottom+0) /180*Math.PI)
			;
		}
		if (e.keyCode == 83 | e.keyCode == 40){ //后
			x =
				Math.cos( (watcher.lookAt.left_right+180) /180*Math.PI)*
				Math.cos( (watcher.lookAt.top_bottom+0) /180*Math.PI)
			;
			z =
				Math.sin( (watcher.lookAt.left_right+180) /180*Math.PI)*
				Math.cos( (watcher.lookAt.top_bottom+0) /180*Math.PI)
			;
		}
		if (e.keyCode == 65 | e.keyCode == 37){ //左
			x =
				Math.cos( (watcher.lookAt.left_right-90) /180*Math.PI)*
				Math.cos( (watcher.lookAt.top_bottom+0) /180*Math.PI)
			;
			z =
				Math.sin( (watcher.lookAt.left_right-90) /180*Math.PI)*
				Math.cos( (watcher.lookAt.top_bottom+0) /180*Math.PI)
			;
		}
		if (e.keyCode == 68 | e.keyCode == 39){ //右
			x =
				Math.cos( (watcher.lookAt.left_right+90) /180*Math.PI)*
				Math.cos( (watcher.lookAt.top_bottom+0) /180*Math.PI)
			;
			z =
				Math.sin( (watcher.lookAt.left_right+90) /180*Math.PI)*
				Math.cos( (watcher.lookAt.top_bottom+0) /180*Math.PI)
			;
		}
		if (e.keyCode == 32){ //上
			y = Math.sin( (watcher.lookAt.top_bottom+180) /180*Math.PI);
		}
		if (e.keyCode == 16){ //下
			y = Math.sin( (watcher.lookAt.top_bottom+0) /180*Math.PI);
		}
		watcher.pos.x += x*10;
		watcher.pos.y += y*10;
		watcher.pos.z += z*10;
	}
	
	let x0 = null, y0 = null;
	document.getElementsByTagName("canvas")[0].onmousedown = function (e){
		console.log("down:", e.screenX, e.screenY);
		[x0,y0] =  [e.screenX, e.screenY];
	};
	document.getElementsByTagName("canvas")[0].onmousemove = function (e){
		if (x0 === null | y0 === null)
			return;
		console.log("move:", e.screenX, e.screenY)
		let [dx, dy] = [e.screenX-x0, e.screenY-y0];
		[x0, y0] = [e.screenX, e.screenY];
		console.log(dx, dy);
		watcher.lookAt.left_right -= dx/document.getElementsByTagName("canvas")[0].offsetWidth*90;
		watcher.lookAt.top_bottom += dy/document.getElementsByTagName("canvas")[0].offsetHeight*90;
		
		if (watcher.lookAt.left_right > 360)
			while (watcher.lookAt.left_right > 360)
				watcher.lookAt.left_right -= 360;
		if (watcher.lookAt.left_right < 0)
			while (watcher.lookAt.left_right < 0)
				watcher.lookAt.left_right += 360;
		
		if (watcher.lookAt.top_bottom > 180)
			watcher.lookAt.top_bottom = 180;
		if (watcher.lookAt.top_bottom < -180)
			watcher.lookAt.top_bottom = -180;
	};
	document.onmouseup = function (){
		x0 = null, y0 = null;
	}
}

//屏蔽选择文字
document.onselectstart = function (){
	return false;
};
</script>
	</body>
</html>